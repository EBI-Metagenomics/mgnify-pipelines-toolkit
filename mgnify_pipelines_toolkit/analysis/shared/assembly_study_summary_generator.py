#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2024-2025 EMBL - European Bioinformatics Institute
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import click
import logging
from pathlib import Path

import pandas as pd

logging.basicConfig(level=logging.DEBUG)


GO_COLUMN_NAMES = {
    "go": "GO",
    "term": "description",
    "category": "category",
}

INTERPRO_COLUMN_NAMES = {
    "interpro_accession": "IPR",
    "description": "description",
}


@click.group()
def cli():
    pass


def generate_taxonomy_summary(file_dict: dict[str, Path], output_prefix: str) -> None:
    """
    Generates a combined taxonomy summary from multiple taxonomy files.

    :param file_dict: Dictionary mapping assembly accession to its taxonomy file.
    :param output_prefix: Prefix for the output summary file.
    #TODO add example of the taxonomy file
    """
    tax_columns = [
        "Count",
        "superkingdom",
        "kingdom",
        "phylum",
        "class",
        "order",
        "family",
        "genus",
        "species",
    ]
    tax_dfs = []

    for assembly_acc, path in file_dict.items():
        df = pd.read_csv(path, sep="\t", names=tax_columns).fillna("")

        # Combine all taxonomic levels into a single string per row
        df["full_taxon"] = df[tax_columns[1:]].agg(";".join, axis=1).str.strip(";")

        # Create a DataFrame with taxonomy as index and count as the only column
        result = df[["Count", "full_taxon"]].set_index("full_taxon")
        result.columns = [assembly_acc]
        tax_dfs.append(result)

    summary_df = pd.concat(tax_dfs, axis=1).fillna(0).astype(int).sort_index()

    summary_df.to_csv(
        f"{output_prefix}_taxonomy_summary.tsv", sep="\t", index_label="taxonomy"
    )


def generate_functional_summary(
    file_dict: dict[str, Path], column_names: dict[str, str], output_prefix, label: str
) -> None:
    """
    Merge multiple summary files into a single summary table.

    Parameters:
        file_dict (dict): Dictionary with assembly IDs as keys and file paths as values.
        output_file (str): Path to write the merged summary file.

    Output:
        A TSV file.
    """
    merged_df = None

    for assembly_acc, filepath in file_dict.items():
        df = pd.read_csv(filepath, sep="\t")

        df = df.rename(columns={**column_names, "count": assembly_acc})

        if merged_df is None:
            merged_df = df
        else:
            merged_df = pd.merge(
                merged_df, df, on=list(column_names.values()), how="outer"
            )
    # Fill NaNs with 0 and make sure count columns are integers
    count_columns = [
        col for col in merged_df.columns if col not in column_names.values()
    ]
    merged_df[count_columns] = merged_df[count_columns].fillna(0).astype(int)

    cols = list(column_names.values()) + [
        col for col in merged_df.columns if col not in column_names.values()
    ]
    merged_df = merged_df[cols]

    merged_df.to_csv(f"{output_prefix}_{label}_summary.tsv", sep="\t", index=False)


@cli.command(
    "summarise",
    options_metavar="-r <assemblies> -a <study_dir> -p <output_prefix>",
    short_help="Generate study-level analysis summaries.",
)
@click.option(
    "-r",
    "--assemblies",
    required=True,
    help="CSV file containing successful analyses generated by the pipeline",
    type=click.Path(exists=True, path_type=Path, dir_okay=False),
)
@click.option(
    "-a",
    "--study_dir",
    required=True,
    help="Input directory to where all the individual analyses subdirectories for summarising",
    type=click.Path(exists=True, path_type=Path, file_okay=False),
)
@click.option(
    "-p", "--output_prefix", required=True, help="Prefix to summary files", type=str
)
def summarise_analyses(assemblies: Path, study_dir: Path, output_prefix: str) -> None:
    """Generate study-level summary files for successfuly proccessed assemblies.

    :param assemblies: Path to a file listing successful assembly accessions and their status.
    :param study_dir: Path to the directory containing analysis results for each assembly.
    :param output_prefix: Prefix for the generated summary files.
    """
    # TODO: this file with successful jobs is not yet published by pipeline
    assemblies_df = pd.read_csv(assemblies, names=["assembly", "status"])
    assembly_list = assemblies_df["assembly"].tolist()

    def get_file_paths(subdir: str, filename_template: str) -> dict[str, Path]:
        return {
            acc: study_dir / acc / subdir / filename_template.format(acc=acc)
            for acc in assembly_list
        }

    # TODO: Add validation for the assemblies_df
    # TODO handle both gz and non-gz files
    generate_taxonomy_summary(
        get_file_paths("taxonomy", "{acc}.krona.txt"), output_prefix
    )

    generate_functional_summary(
        get_file_paths("functional-annotation/interpro", "{acc}_interpro_summary.tsv"),
        INTERPRO_COLUMN_NAMES,
        output_prefix,
        "interpro",
    )

    generate_functional_summary(
        get_file_paths("functional-annotation/go", "{acc}_go_summary.tsv"),
        GO_COLUMN_NAMES,
        output_prefix,
        "go",
    )

    generate_functional_summary(
        get_file_paths("functional-annotation/go", "{acc}_goslim_summary.tsv"),
        GO_COLUMN_NAMES,
        output_prefix,
        "goslim",
    )


@cli.command(
    "merge",
    options_metavar="-a <study_dir> -p <output_prefix>",
    short_help="Merge multiple study-level analysis summaries.",
)
@click.option(
    "-a",
    "--study_dir",
    required=True,
    help="Input directory to where all the individual analyses subdirectories for merging",
    type=click.Path(exists=True, file_okay=False),
)
@click.option(
    "-p",
    "--output_prefix",
    required=True,
    help="Prefix to merged summary files",
    type=str,
)
def merge_summaries(study_dir: str, output_prefix: str) -> None:
    """Function that will take a file path containing study-level
    summaries that should be merged together.
    \f

    :param study_dir: The filepath to the directory containing all of the analyses.
    :type study_dir: str
    :param output_prefix: Prefix to be added to the generated summary file.
    :type output_prefix: str
    """
    pass


if __name__ == "__main__":
    cli()
